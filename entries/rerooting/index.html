<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Rerooting (全方位木 DP) の気持ち - kuretchi's blog</title>
    <meta property="og:url" content="/blog/entries/rerooting/index.html" />
    <meta property="og:title" content="Rerooting (全方位木 DP) の気持ち - kuretchi's blog" />
    <meta name="twitter:card" content="summary" />
    <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #ffffff; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #0057ae; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */
    </style>
    <link rel="stylesheet" href="https://unpkg.com/ress/dist/ress.min.css" />
    <link rel="stylesheet" href="/blog/style.css" />
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div id="global-container">
      <header id="global-header">
        <div id="global-header-container">
          <a id="blog-title" href="/blog/">kuretchi's blog</a>
        </div>
      </header>
      <article id="content">
        <header class="entry-header">
          <h1 class="entry-title">Rerooting (全方位木 DP) の気持ち</h1>
            <time class="entry-date" datetime="2020-04-15">2020-04-15</time>
          </header>
        <div id="body-container">
<p>一から説明していますが，既に大まかには分かっている人向けです．二項演算で畳み込むタイプの中では最も汎用的<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>だと思います．</p>
<h2 id="解説">解説</h2>
<h3 id="根付き木の畳み込み-木-dp">根付き木の畳み込み<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> (木 DP)</h3>
<p>ここでいう根付き木とは，ひとまず，Haskell で書くと次のようになるデータ構造を指すことにします．</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Tree</span> v e <span class="ot">=</span> <span class="dt">Tree</span> v [(e, <span class="dt">Tree</span> v e)]</span></code></pre></div>
<p><code>v</code> は頂点に乗っている値の型，<code>e</code> は辺に乗っている値 (重みとか距離とか) の型です．根と，根に隣接する辺とその先の部分木の対のリスト<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>が根付き木であると定義しました．</p>
<p>この <code>Tree v e</code> に，何も考えず fold を実装するなら次のようになると思います．</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">foldTree ::</span> (v <span class="ot">-&gt;</span> [(e, a)] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Tree</span> v e <span class="ot">-&gt;</span> a</span>
<span id="cb2-2"><a href="#cb2-2"></a>foldTree f (<span class="dt">Tree</span> v t) <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  f v <span class="op">.</span> <span class="fu">map</span> (\ (e, st) <span class="ot">-&gt;</span> (e, foldTree f st)) <span class="op">$</span> t</span></code></pre></div>
<p><code>a</code> は部分木の値の型と言って良いでしょう．ここで，<code>f :: v -&gt; [(e, a)] -&gt; a</code> は，頂点の値と，辺とその先の部分木の値の対のリストを受け取って，部分木の値を返す仕事をしています．これをもう少し分解します．</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">foldTree ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">Tree</span> v e <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2"></a>foldTree f g (<span class="dt">Tree</span> v t) <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  f v <span class="op">.</span> <span class="fu">mconcat</span> <span class="op">.</span> <span class="fu">map</span> (\ (e, st) <span class="ot">-&gt;</span> g e (foldTree f g st)) <span class="op">$</span> t</span></code></pre></div>
<p>先ほど出てきたリストは，何かのモノイドの演算で concat することにしました．そのために，先ほどの <code>f</code> に対応する関数は，辺の値と部分木の値を受け取ってモノイドの要素を返す <code>g :: e -&gt; a -&gt; m</code> と，頂点の値とモノイドの要素を受け取って部分木の値を返す <code>f :: v -&gt; m -&gt; a</code> の二つになりました．</p>
<p>このアルゴリズムは，頂点数を <span class="math inline">\(n\)</span> として <span class="math inline">\(\Theta(n)\)</span> 時間で動作します<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>．</p>
<p>以下では，考える根付き木 <span class="math inline">\(t\)</span>，部分木の値の集合 <span class="math inline">\(A\)</span>，モノイド <span class="math inline">\(M\)</span>，および <span class="math inline">\(f : V \times M \to A\)</span>，<span class="math inline">\(g : E \times A \to M\)</span> を固定して，<span class="math inline">\(\mathrm{val}(t)\)</span> を上のように計算した <span class="math inline">\(t\)</span> の値とします．<span class="math inline">\(M\)</span> の二項演算を <span class="math inline">\(\odot\)</span>，単位元を <span class="math inline">\(1_M\)</span> とします．<span class="math inline">\(t\)</span> の頂点数は十分大きいとします．</p>
<h3 id="rerooting-全方位木-dp">Rerooting (全方位木 DP)</h3>
<p>いったん根のことは忘れて，単なる (無向) 木として考えます．頂点数を <span class="math inline">\(n\)</span> とします．木は隣接リストとして持っているとし，頂点には <span class="math inline">\(0\)</span> から <span class="math inline">\(n - 1\)</span> の添字が振られているとして，それを頂点の値の代わりとします．</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">type</span> Tree<span class="op">&lt;</span>E<span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span>(E<span class="op">,</span> <span class="dt">usize</span>)<span class="op">&gt;&gt;;</span></span></code></pre></div>
<p>注意として，辺は双方向に同じ値のものが張ってあるとします．つまり，任意の頂点 <code>src</code>，<code>dst</code>，辺の値 <code>e</code>，添字 <code>i</code> について「<code>t[src][i] == (e, dst)</code> であるなら，ある <code>j</code> が存在して <code>t[dst][j] == (e, src)</code>」が成り立つとします．</p>
<p>頂点 <span class="math inline">\(u\)</span> と <span class="math inline">\(v\)</span> を繋ぐ辺が存在するとき，その値を <span class="math inline">\(e_{u, v}\)</span> (<span class="math inline">\(= e_{v, u}\)</span>) とします．</p>
<p>木をこのように持つと，頂点を一つ指定することで，その頂点を根とする根付き木が一意に定まります．前述した通り，<span class="math inline">\(v\)</span> を根とする根付き木の値を <span class="math inline">\(\mathrm{val}(v)\)</span> とします．</p>
<p>また，そのような根付き木に対し，さらに頂点を一つ指定することで，その頂点を根とする部分木が一意に定まります．そのような部分木には，その根がもとの木の根と異なるときには，ちょうど一つだけ親となる頂点が存在するので，(部分木の) 根と親を決めることでも部分木は一意に定まります．そこで，<span class="math inline">\(v\)</span> を (部分木の) 根，<span class="math inline">\(p\)</span> を親としたときの部分木の値を <span class="math inline">\(\mathrm{val}_p(v)\)</span> とします．</p>
<p><span class="math inline">\(g\mathrm{val} _ {u}(v) = g(e_{u, v}, \mathrm{val}_{u}(v))\)</span> とします．</p>
<p>さて，次の問題を考えます：すべての頂点 <span class="math inline">\(v\)</span> について，それぞれ <span class="math inline">\(\mathrm{val}(v)\)</span> を求めよ．すなわち，列 <span class="math inline">\((\mathrm{val}(v))_{v = 0}^{n - 1}\)</span> を求めよ．</p>
<p>これは，上述した根付き木の畳み込みをすべての頂点について行えば <span class="math inline">\(\Theta(n^2)\)</span> ですが，これから説明する Rerooting と呼ばれるテクニックを用いることで <span class="math inline">\(\Theta(n)\)</span> に落ちます．</p>
<p>さて，まず任意の頂点を一つ選び，それを根とした根付き木を考えます．ここではそのような頂点として <span class="math inline">\(0\)</span> を選ぶことにします．この根付き木の畳み込みをして <span class="math inline">\(\mathrm{val}(0)\)</span> を求める気持ちで，<em>ついでに</em>，その過程で求まる部分木の値をすべてメモしておくことにします．</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1"></a>generator next(tree, parent, root):</span>
<span id="cb5-2"><a href="#cb5-2"></a>  for (e, dst) in tree[root]:</span>
<span id="cb5-3"><a href="#cb5-3"></a>    if dst == parent:</span>
<span id="cb5-4"><a href="#cb5-4"></a>      continue</span>
<span id="cb5-5"><a href="#cb5-5"></a>    yield (e, dst)</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a>procedure scanTree(tree, parent, root):</span>
<span id="cb5-8"><a href="#cb5-8"></a>  acc &lt;- 1</span>
<span id="cb5-9"><a href="#cb5-9"></a>  for (e, dst) in next(tree, parent, root):</span>
<span id="cb5-10"><a href="#cb5-10"></a>    scanTree(tree, root, dst)</span>
<span id="cb5-11"><a href="#cb5-11"></a>    acc &lt;- acc * g(e, val[root][dst])</span>
<span id="cb5-12"><a href="#cb5-12"></a>  val[parent].insert(root, f(root, acc))</span></code></pre></div>
<p><code>scanTree(t, nil, 0)</code> を呼びます．これが終わった後には，<code>val[p].containsKey(v)</code> であれば <code>val[p][v]</code> に <span class="math inline">\(\mathrm{val}_p(v)\)</span> が入っています．<code>val[p].containsKey(v)</code> であることを <span class="math inline">\(\mathrm{val}_p(v)\)</span> は<em>計算済み</em>であると呼ぶことにします．</p>
<p>今，頂点 <span class="math inline">\(0\)</span> に隣接する任意の頂点 <span class="math inline">\(v\)</span> について，<span class="math inline">\(\mathrm{val}_0(v)\)</span> は計算済みです．ここで，そのような <span class="math inline">\(v\)</span> を一つ取って，<span class="math inline">\(\mathrm{val}_v(0)\)</span> を考えます．これはどのような値でしょうか？ 最初，頂点 <span class="math inline">\(0\)</span> は根だったので親を持ちませんでした．しかし今度は，頂点 <span class="math inline">\(0\)</span> に唯一の親 <span class="math inline">\(v\)</span> ができることになります．つまり，<span class="math inline">\(\mathrm{val}_v(0)\)</span> は，<span class="math inline">\(\mathrm{val}(0)\)</span> から <span class="math inline">\(\mathrm{val}_0(v)\)</span> を<em>取り除いた</em>値になっています．きちんと言うと，<span class="math inline">\(\mathrm{val}(0) = f(0, \bigodot _{u \text{は} 0 \text{に隣接する}} g\mathrm{val}_0(u))\)</span> であったことに注意して，<span class="math inline">\(\mathrm{val}_v(0) = f(0, \bigodot _{u \text{は} 0 \text{に隣接する} \land u \ne v} g\mathrm{val}_0(u))\)</span> であるということです．</p>
<p>以上を踏まえて，頂点 <span class="math inline">\(0\)</span> に隣接するすべての頂点 <span class="math inline">\(v\)</span> について，<span class="math inline">\(\mathrm{val}_v(0)\)</span> を求めることを考えます．頂点 <span class="math inline">\(0\)</span> に隣接する頂点の列を <span class="math inline">\((v_i)_{i = 0}^{\deg(0) - 1}\)</span> とし，列 <span class="math inline">\((r_i)_{i = 0}^{\deg(0) - 1}\)</span> を <span class="math inline">\(r _{\deg(0) - 1} = 1_M\)</span>，<span class="math inline">\(r_i = g\mathrm{val}_{0}(v _{i + 1}) \odot r _{i + 1} \ (i \lt \deg(0))\)</span> で，列 <span class="math inline">\((l_i)_{i = 0}^{\deg(0) - 1}\)</span> を <span class="math inline">\(l_0 = 1_M\)</span>，<span class="math inline">\(l_i = l_{i - 1} \odot g\mathrm{val}_{0}(v _{i - 1}) \ (i \gt 0)\)</span> でそれぞれ定めます．これらは <span class="math inline">\(\Theta(\deg(0))\)</span> で計算できます．</p>
<p>今，任意の <span class="math inline">\(i\)</span> (<span class="math inline">\(0 \le i \le \deg(0) - 1\)</span>) について，<span class="math inline">\(f(0, l_i \odot r_i) = f(0, (\bigodot_{j = 0}^{i - 1} g\mathrm{val}_{0}(v_j)) \odot (\bigodot_{j = i + 1}^{\deg(0) - 1} g\mathrm{val}_{0}(v_j))) = \mathrm{val} _ {v_i}(0)\)</span> です．<span class="math inline">\(l_i\)</span> と <span class="math inline">\(r_i\)</span> はすでに手に入っているので，これは <span class="math inline">\(\Theta(1)\)</span> で得られます．というわけで，<span class="math inline">\(\Theta(\deg(0))\)</span> で，頂点 <span class="math inline">\(0\)</span> に隣接するすべての頂点 <span class="math inline">\(v\)</span> について <span class="math inline">\(\mathrm{val}_v(0)\)</span> が得られました．</p>
<p>さらに，<span class="math inline">\(f(0, l_{\deg(0) - 1} \odot g\mathrm{val}_{0}(v _ {\deg(0) - 1})) = \mathrm{val}(0)\)</span> であることに注意してください．</p>
<p>ここでまたしても，頂点 <span class="math inline">\(0\)</span> に隣接する頂点 <span class="math inline">\(v\)</span> を一つ取ってきて，今度は <span class="math inline">\(\mathrm{val}(v)\)</span> を求めることを考えます．しかし，実は先程の頂点 <span class="math inline">\(0\)</span> の場合と状況は同じで，頂点 <span class="math inline">\(v\)</span> に隣接する任意の頂点 <span class="math inline">\(u\)</span> について，<span class="math inline">\(\mathrm{val}_{v}(u)\)</span> は計算済みです．なぜなら，最初の <code>scanTree(t, nil, 0)</code> が終わった段階では唯一計算済みでなかった <span class="math inline">\(\mathrm{val}_v(0)\)</span> は，たった今計算したからです．</p>
<p>というわけで，以上を適当なトポロジカル順序ですべての頂点に対して行えば，すべての頂点 <span class="math inline">\(v\)</span> について <span class="math inline">\(\mathrm{val}(v)\)</span> が求まります．全体の計算量は，それぞれの頂点 <span class="math inline">\(v\)</span> についての計算量を <span class="math inline">\(T(v)\)</span> とすると，<span class="math inline">\(\Theta(\sum_{v = 0}^{n - 1} T(v))\)</span> で，<span class="math inline">\(T(v) \in \Theta(\deg(v))\)</span> であったので <span class="math inline">\(\Theta(n)\)</span> です<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>．</p>
<h2 id="実践">実践</h2>
<ul>
<li><p><a href="https://atcoder.jp/contests/arc028/tasks/arc028_3">AtCoder Regular Contest 028 C - 高橋王国の分割統治</a></p>
<ul>
<li><span class="math inline">\(A = \mathbb{N} \times \mathbb{N}\)</span>
<ul>
<li>部分木の頂点数と「バランス値」</li>
</ul></li>
<li><span class="math inline">\(M = \langle \mathbb{N}, + \rangle \times \langle \mathbb{N}, \max \rangle\)</span>
<ul>
<li>部分木の頂点数と「バランス値」</li>
</ul></li>
<li><span class="math inline">\(f(v, \langle n, b \rangle) = \langle n + 1, b \rangle\)</span></li>
<li><span class="math inline">\(g(e, \langle n, b \rangle) = \langle n, n \rangle\)</span></li>
</ul></li>
</ul>
<p>TODO: その他の例を加える</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://ecasd-qina.hatenablog.com/entry/2020/04/01/010818">もうひとつのるま式全方位木 DP - -!=x=!-</a></li>
<li><a href="https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e">【全方位木DP】明日使える便利な木構造のアルゴリズム - Qiita</a></li>
<li><a href="https://ei1333.hateblo.jp/entry/2018/12/21/004022">もうひとつの全方位木DP - ei1333の日記</a></li>
<li><a href="https://twitter.com/tmaehara/status/980787099472297985">™ 🔰さんはTwitterを使っています 「全方位木DP（rerooting）をイラストにしました https://t.co/TFQsk0rkBL」 / Twitter</a></li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>辺に何かが乗っているときや，部分木の値を二項演算で潰す前に何らかの変換をしたい場合に対応できます．<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>convolution ではなく，<a href="https://ja.wikipedia.org/wiki/%E9%AB%98%E9%9A%8E%E9%96%A2%E6%95%B0#fold">fold</a> とか呼ばれるもの<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>今後，このリストの要素は順不同であると思う人 (つまり，リストではなく単なる集合であるべきと考える人) は，すぐ後に出てくるモノイドの条件に可換であることを付け加えてください．<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><code>f</code> や <code>g</code>，モノイドの演算などはすべて定数時間で計算できるとします．<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>トポロジカルソートの計算量は <span class="math inline">\(O(n)\)</span> です．<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
        </div>
      </article>
      <footer id="global-footer">
        <div id="global-footer-container">
          <small class="copyright">&copy; 2020 kuretchi</small>
        </div>
      </footer>
    </div>
  </body>
</html>
